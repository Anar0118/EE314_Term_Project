
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Term_Project(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N, 
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire reset = SW[9];
wire clk_out, clk_out2, clk_mux;

wire        video_on;
wire        hsync, vsync;
wire [3:0]  bg_r, bg_g, bg_b;

wire [9:0] hcnt, vcnt;

wire [9:0] p1_x;
wire [2:0] p1_state;
wire p1_attacking;


//=======================================================
//  Structural coding
//=======================================================




Clock_Divider #(.DIVISOR(2)) clock25(
.clk(CLOCK_50),
.reset(reset),
.clk_out(clk_out)
);

Clock_Divider #(.DIVISOR(833334)) clock60(
.clk(CLOCK_50),
.reset(reset),
.clk_out(clk_out2)
);

MUXx #(.W(1)) clock_mux(
.select(SW[1]),
.mux_input_0(clk_out2),
.mux_input_1(~KEY[0]),
.mux_output(clk_mux)
);


vga_background background(
.clk(clk_out),
.reset(reset),
.video_on(video_on),
.hsync(hsync),
.vsync(vsync),
.red(bg_r),
.green(bg_g),
.blue(bg_b),
.hcnt(hcnt),
.vcnt(vcnt)
);

/*
// 3) wire to the physical VGA pins
assign VGA_HS      = hsync;
assign VGA_VS      = vsync;
assign VGA_BLANK_N = video_on;    // active-high blank
assign VGA_SYNC_N  = 1'b1;        // we’re not using composite sync
assign VGA_CLK = clk_out;
// expand 4-bit color channels to 8 bits
assign VGA_R = { bg_r, 4'h0 };
assign VGA_G = { bg_g, 4'h0 };
assign VGA_B = { bg_b, 4'h0 };
*/

//wire [9:0] p1_x;
//wire [2:0] p1_state;

FSM fsm1(
.clk(clk_mux),
.reset(reset),
.btn_left(~KEY[3]),
.btn_right(~KEY[1]),
.btn_attack(~KEY[2]),
.x_pos(p1_x),
.state(p1_state),
.attacking(p1_attacking)
);


hexto7seg fsm1_state(
.hex(p1_state),
.hexn(HEX0)
);


//----------------------------------------------------------------------  
// 3) single-player sprite renderer
//----------------------------------------------------------------------  
// Hard-coded start position; later drive this from your FSM!
//localparam [9:0] P1_X = 40;
localparam [9:0] P1_Y = 120;

wire        sprite_on;
wire [3:0]  spr_r, spr_g, spr_b;

character_renderer player1 (
.video_on(video_on),
.hcnt(hcnt),
.vcnt(vcnt),
.x_pos(p1_x),
.y_pos(P1_Y),
.attacking(p1_attacking),
.state(p1_state),
.switch(SW[2]),
.sprite_on(sprite_on),
.r(spr_r),
.g(spr_g),
.b(spr_b)
);

//----------------------------------------------------------------------  
// 4) final RGB mux: sprite over background
//----------------------------------------------------------------------  
wire [3:0] final_r = sprite_on ? spr_r : bg_r;
wire [3:0] final_g = sprite_on ? spr_g : bg_g;
wire [3:0] final_b = sprite_on ? spr_b : bg_b;

// expand 4-bit → 8-bit for the DE1-SoC header
assign VGA_R       = { final_r, 4'h0 };
assign VGA_G       = { final_g, 4'h0 };
assign VGA_B       = { final_b, 4'h0 };
assign VGA_CLK     = clk_out;
assign VGA_HS      = hsync;
assign VGA_VS      = vsync;
assign VGA_BLANK_N = video_on;
assign VGA_SYNC_N  = 1'b1;


endmodule