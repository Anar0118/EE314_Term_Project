
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module Term_Project(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// SEG7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// VGA //////////
	output		          		VGA_BLANK_N, 
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,
	
	//////////// PS2 //////////
	input 		          		PS2_CLK,
	input 		          		PS2_CLK2,
	input 		          		PS2_DAT,
	input 		          		PS2_DAT2
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire reset = SW[9];
wire clk_out, clk_out2, clk_mux;

wire        video_on;
wire        hsync, vsync;
wire [3:0]  bg_r, bg_g, bg_b;

wire [9:0] hcnt, vcnt;

wire [9:0] p1_x;
wire [9:0] p2_x;
wire [2:0] p1_state;
wire [2:0] p2_state;
wire p1_attacking;
wire p2_attacking;
wire p1_dir_attacking;
wire p2_dir_attacking;
wire [4:0] p1_attack_frame;
wire [4:0] p2_attack_frame;

/*
// PS/2 Keyboard signals
wire [7:0] key_code;
wire key_pressed, key_released, key_ready;
wire p1_left, p1_right, p1_attack;
wire p2_left, p2_right, p2_attack;
*/
//=======================================================
//  Structural coding
//=======================================================

Clock_Divider #(.DIVISOR(2)) clock25(
.clk(CLOCK_50),
.reset(reset),
.clk_out(clk_out)
);

Clock_Divider #(.DIVISOR(833334)) clock60(
.clk(CLOCK_50),
.reset(reset),
.clk_out(clk_out2)
);

MUXx #(.W(1)) clock_mux(
.select(SW[1]),
.mux_input_0(clk_out2),
.mux_input_1(~KEY[0]),
.mux_output(clk_mux)
);

wire select_mux;

MUXx #(.W(1)) game_select(
.select(SW[0]),
.mux_input_0(1'd0),
.mux_input_1(1'd1),
.mux_output(select_mux)
);


wire       menu_active, ctrl_countdown, countdown_active, play_active;
wire [1:0] game_mode;      // 0 = unused, 1 = 1P, 2 = 2P

menu menu_control(
.clk(clk_mux),
.reset(reset),
.select(select_mux),
.btn_confirm(~KEY[2]),   // e.g. KEY[1] debounced
.game_mode(game_mode),
.menu_active(menu_active),
.countdown_active(ctrl_countdown),
.play_active(play_active)
);

hexto7seg hex_select(
.hex(game_mode),
.hexn(HEX5)
);

// COUNTDOWN overlay
wire [3:0] cd_r, cd_g, cd_b;
wire [1:0] cd_value;  // 0=“3”,1=“2”,2=“1”,3=“GO”

countdown_fsm cd_fsm(
.clk(clk_mux),
.reset(reset),
.start(ctrl_countdown && (~KEY[2])),
.cd_value(cd_value),
.active(countdown_active)
);

vga_background background(
.clk(clk_out),
.reset(reset),
.video_on(video_on),
.hsync(hsync),
.vsync(vsync),
.red(bg_r),
.green(bg_g),
.blue(bg_b),
.hcnt(hcnt),
.vcnt(vcnt)
);


// MENU overlay
wire [3:0] menu_r, menu_g, menu_b;
menu_renderer menu_i(
.video_on(video_on & menu_active),
.hcnt(hcnt),
.vcnt(vcnt),
.selected(game_mode),
.r(menu_r),
.g(menu_g),
.b(menu_b)
);

countdown_renderer cd_rend (
.video_on(video_on & countdown_active),
.hcnt(hcnt),
.vcnt(vcnt),
.cd_value(cd_value),
.r(cd_r),
.g(cd_g),
.b(cd_b)
);

/*
// 3) wire to the physical VGA pins
assign VGA_HS      = hsync;
assign VGA_VS      = vsync;
assign VGA_BLANK_N = video_on;    // active-high blank
assign VGA_SYNC_N  = 1'b1;        // we’re not using composite sync
assign VGA_CLK = clk_out;
// expand 4-bit color channels to 8 bits
assign VGA_R = { bg_r, 4'h0 };
assign VGA_G = { bg_g, 4'h0 };
assign VGA_B = { bg_b, 4'h0 };
*/

//wire [9:0] p1_x;
//wire [2:0] p1_state;

// Character#1 FSM
FSM_1 fsm1(
.clk(clk_mux),
.reset(reset),
.btn_left(~KEY[3]),
.btn_right(~KEY[1]),
.btn_attack(~KEY[2]),
.x_pos_opponent(p2_x),
.play_active(play_active),
.x_pos(p1_x),
.state(p1_state),
.attacking(p1_attacking),
.dir_attacking(p1_dir_attacking),
.attack_frame(p1_attack_frame)
);

// Character#2 FSM
FSM_2 fsm2(
.clk(clk_mux),
.reset(reset),
.btn_left(SW[6]),
.btn_right(SW[8]),
.btn_attack(SW[7]),
.x_pos_opponent(p1_x),
.play_active(play_active),
.x_pos(p2_x),
.state(p2_state),
.attacking(p2_attacking),
.dir_attacking(p2_dir_attacking),
.attack_frame(p2_attack_frame)
);


hexto7seg fsm1_state(
.hex(p1_state),
.hexn(HEX0)
);

hexto7seg fsm2_state(
.hex(p2_state),
.hexn(HEX1)
);

hexto7seg fsm1_attack_frame(
.hex(p1_attack_frame),
.hexn(HEX2)
);

hexto7seg fsm2_attack_frame(
.hex(p2_attack_frame),
.hexn(HEX3)
);


//----------------------------------------------------------------------  
// 3) single-player sprite renderer
//----------------------------------------------------------------------  
// Hard-coded start position; later drive this from your FSM!
//localparam [9:0] P1_X = 40;
localparam [9:0] P1_Y = 120;
localparam [9:0] P2_Y = 120;

wire        sprite1_on;
wire [3:0]  spr_r, spr_g, spr_b;

wire        sprite2_on;
wire [3:0]  spr2_r, spr2_g, spr2_b;


// Character#1 Renderer
character_renderer player1(
.video_on(video_on),
.hcnt(hcnt),
.vcnt(vcnt),
.x_pos(p1_x),
.y_pos(P1_Y),
.attacking(p1_attacking),
.dir_attacking(p1_dir_attacking),
.state(p1_state),
.switch(SW[2]),
.player_num(0),
.sprite_on(sprite1_on),
.r(spr_r),
.g(spr_g),
.b(spr_b)
);

// Character#2 Renderer
character_renderer player2(
.video_on(video_on),
.hcnt(hcnt),
.vcnt(vcnt),
.x_pos(p2_x),
.y_pos(P2_Y),
.attacking(p2_attacking),
.dir_attacking(p2_dir_attacking),
.state(p2_state),
.switch(SW[2]),
.player_num(1),
.sprite_on(sprite2_on),
.r(spr2_r),
.g(spr2_g),
.b(spr2_b)
);

wire hit1_flag, hit2_flag,stun1_flag, stun2_flag;

Hit_Detector detector(
.clk(clk_mux),
.reset(reset),
.state_1(p1_state),
.state_2(p2_state),
.p1_x(p1_x),
.p2_x(p2_x),
.attacking1(p1_attacking),
.dir_attacking1(p1_dir_attacking),
.attacking2(p2_attacking),
.dir_attacking2(p2_dir_attacking),
.hit1_flag(hit1_flag),
.hit2_flag(hit2_flag),
.stun1_flag(stun1_flag),
.stun2_flag(stun2_flag),
//.leds({{LEDR[9],LEDR[8],LEDR[7]},{LEDR[0],LEDR[1],LEDR[2]}})
.led1(LEDR[9]),
.led2(LEDR[8]),
.led3(LEDR[7]),
.led4(LEDR[0]),
.led5(LEDR[1]),
.led6(LEDR[2])
);






//========================================================================
// 9) Final pixel mux: menu → countdown → play → background
//========================================================================
wire [3:0] final_r = menu_active     ? menu_r      :
						  countdown_active ? cd_r        :
						  play_active      ? (sprite2_on ? spr2_r : sprite1_on ? spr_r : bg_r)
												 : bg_r;
wire [3:0] final_g = menu_active     ? menu_g      :
						  countdown_active ? cd_g        :
						  play_active      ? (sprite2_on ? spr2_g : sprite1_on ? spr_g : bg_g)
												 : bg_g;
wire [3:0] final_b = menu_active     ? menu_b      :
						  countdown_active ? cd_b        :
						  play_active      ? (sprite2_on ? spr2_b : sprite1_on ? spr_b : bg_b)
												 : bg_b;







/*
// Priority: Player 2 > Player 1 > Background
wire [3:0] final_r = sprite2_on ? spr2_r : (sprite1_on ? spr_r : bg_r);
wire [3:0] final_g = sprite2_on ? spr2_g : (sprite1_on ? spr_g : bg_g);
wire [3:0] final_b = sprite2_on ? spr2_b : (sprite1_on ? spr_b : bg_b);
*/

//wire collision = (sprite_on && sprite2_on);
//assign LEDR[4] = collision;  // Visual feedback

//----------------------------------------------------------------------  
// 4) final RGB mux: sprite over background
//----------------------------------------------------------------------  
//wire [3:0] final_r = sprite_on ? spr_r : bg_r;
//wire [3:0] final_g = sprite_on ? spr_g : bg_g;
//wire [3:0] final_b = sprite_on ? spr_b : bg_b;

// expand 4-bit → 8-bit for the DE1-SoC header
assign VGA_R       = { final_r, 4'h0 };
assign VGA_G       = { final_g, 4'h0 };
assign VGA_B       = { final_b, 4'h0 };
assign VGA_CLK     = clk_out;
assign VGA_HS      = hsync;
assign VGA_VS      = vsync;
assign VGA_BLANK_N = video_on;
assign VGA_SYNC_N  = 1'b1;


endmodule